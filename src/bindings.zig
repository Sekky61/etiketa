// auto generated by c2z
const std = @import("std");
// bring in types like uid_t
const linux = std.os.linux;
// S means set. Brings in flag constants
const S = linux.S;

pub const FUSE_MAJOR_VERSION = @as(c_int, 3);
pub const FUSE_MINOR_VERSION = @as(c_int, 16);
pub inline fn FUSE_MAKE_VERSION(maj: anytype, min: anytype) @TypeOf((maj * @as(c_int, 100)) + min) {
    _ = &maj;
    _ = &min;
    return (maj * @as(c_int, 100)) + min;
}
pub const FUSE_VERSION = FUSE_MAKE_VERSION(FUSE_MAJOR_VERSION, FUSE_MINOR_VERSION);
pub const FUSE_CAP_ASYNC_READ = @as(c_int, 1) << @as(c_int, 0);
pub const FUSE_CAP_POSIX_LOCKS = @as(c_int, 1) << @as(c_int, 1);
pub const FUSE_CAP_ATOMIC_O_TRUNC = @as(c_int, 1) << @as(c_int, 3);
pub const FUSE_CAP_EXPORT_SUPPORT = @as(c_int, 1) << @as(c_int, 4);
pub const FUSE_CAP_DONT_MASK = @as(c_int, 1) << @as(c_int, 6);
pub const FUSE_CAP_SPLICE_WRITE = @as(c_int, 1) << @as(c_int, 7);
pub const FUSE_CAP_SPLICE_MOVE = @as(c_int, 1) << @as(c_int, 8);
pub const FUSE_CAP_SPLICE_READ = @as(c_int, 1) << @as(c_int, 9);
pub const FUSE_CAP_FLOCK_LOCKS = @as(c_int, 1) << @as(c_int, 10);
pub const FUSE_CAP_IOCTL_DIR = @as(c_int, 1) << @as(c_int, 11);
pub const FUSE_CAP_AUTO_INVAL_DATA = @as(c_int, 1) << @as(c_int, 12);
pub const FUSE_CAP_READDIRPLUS = @as(c_int, 1) << @as(c_int, 13);
pub const FUSE_CAP_READDIRPLUS_AUTO = @as(c_int, 1) << @as(c_int, 14);
pub const FUSE_CAP_ASYNC_DIO = @as(c_int, 1) << @as(c_int, 15);
pub const FUSE_CAP_WRITEBACK_CACHE = @as(c_int, 1) << @as(c_int, 16);
pub const FUSE_CAP_NO_OPEN_SUPPORT = @as(c_int, 1) << @as(c_int, 17);
pub const FUSE_CAP_PARALLEL_DIROPS = @as(c_int, 1) << @as(c_int, 18);
pub const FUSE_CAP_POSIX_ACL = @as(c_int, 1) << @as(c_int, 19);
pub const FUSE_CAP_HANDLE_KILLPRIV = @as(c_int, 1) << @as(c_int, 20);
pub const FUSE_CAP_CACHE_SYMLINKS = @as(c_int, 1) << @as(c_int, 23);
pub const FUSE_CAP_NO_OPENDIR_SUPPORT = @as(c_int, 1) << @as(c_int, 24);
pub const FUSE_CAP_EXPLICIT_INVAL_DATA = @as(c_int, 1) << @as(c_int, 25);
pub const FUSE_CAP_EXPIRE_ONLY = @as(c_int, 1) << @as(c_int, 26);
pub const FUSE_CAP_SETXATTR_EXT = @as(c_int, 1) << @as(c_int, 27);
pub const FUSE_IOCTL_COMPAT = @as(c_int, 1) << @as(c_int, 0);
pub const FUSE_IOCTL_UNRESTRICTED = @as(c_int, 1) << @as(c_int, 1);
pub const FUSE_IOCTL_RETRY = @as(c_int, 1) << @as(c_int, 2);
pub const FUSE_IOCTL_DIR = @as(c_int, 1) << @as(c_int, 4);
pub const FUSE_IOCTL_MAX_IOV = @as(c_int, 256);
pub const _FCNTL_H = @as(c_int, 1);
pub const __O_LARGEFILE = @as(c_int, 0);
pub const F_GETLK64 = @as(c_int, 5);
pub const F_SETLK64 = @as(c_int, 6);
pub const F_SETLKW64 = @as(c_int, 7);
pub const O_ACCMODE = @as(c_int, 0o003);
pub const O_RDONLY = @as(c_int, 0o0);
pub const O_WRONLY = @as(c_int, 0o1);
pub const O_RDWR = @as(c_int, 0o2);
pub const O_CREAT = @as(c_int, 0o100);
pub const O_EXCL = @as(c_int, 0o200);
pub const O_NOCTTY = @as(c_int, 0o400);
pub const O_TRUNC = @as(c_int, 0o1000);
pub const O_APPEND = @as(c_int, 0o2000);
pub const O_NONBLOCK = @as(c_int, 0o4000);
pub const O_NDELAY = O_NONBLOCK;
pub const O_SYNC = std.zig.c_translation.promoteIntLiteral(c_int, 0o4010000, .octal);
pub const O_FSYNC = O_SYNC;
pub const O_ASYNC = @as(c_int, 0o20000);
pub const __O_DIRECTORY = std.zig.c_translation.promoteIntLiteral(c_int, 0o200000, .octal);
pub const __O_NOFOLLOW = std.zig.c_translation.promoteIntLiteral(c_int, 0o400000, .octal);
pub const __O_CLOEXEC = std.zig.c_translation.promoteIntLiteral(c_int, 0o2000000, .octal);
pub const __O_DIRECT = @as(c_int, 0o40000);
pub const __O_NOATIME = std.zig.c_translation.promoteIntLiteral(c_int, 0o1000000, .octal);
pub const __O_PATH = std.zig.c_translation.promoteIntLiteral(c_int, 0o10000000, .octal);
pub const __O_DSYNC = @as(c_int, 0o10000);
pub const __O_TMPFILE = std.zig.c_translation.promoteIntLiteral(c_int, 0o20000000, .octal) | __O_DIRECTORY;
pub const F_GETLK = F_GETLK64;
pub const F_SETLK = F_SETLK64;
pub const F_SETLKW = F_SETLKW64;
pub const O_DIRECTORY = __O_DIRECTORY;
pub const O_NOFOLLOW = __O_NOFOLLOW;
pub const O_CLOEXEC = __O_CLOEXEC;
pub const O_DSYNC = __O_DSYNC;
pub const O_RSYNC = O_SYNC;
pub const F_DUPFD = @as(c_int, 0);
pub const F_GETFD = @as(c_int, 1);
pub const F_SETFD = @as(c_int, 2);
pub const F_GETFL = @as(c_int, 3);
pub const F_SETFL = @as(c_int, 4);
pub const __F_SETOWN = @as(c_int, 8);
pub const __F_GETOWN = @as(c_int, 9);
pub const F_SETOWN = __F_SETOWN;
pub const F_GETOWN = __F_GETOWN;
pub const __F_SETSIG = @as(c_int, 10);
pub const __F_GETSIG = @as(c_int, 11);
pub const __F_SETOWN_EX = @as(c_int, 15);
pub const __F_GETOWN_EX = @as(c_int, 16);
pub const F_DUPFD_CLOEXEC = @as(c_int, 1030);
pub const FD_CLOEXEC = @as(c_int, 1);
pub const F_RDLCK = @as(c_int, 0);
pub const F_WRLCK = @as(c_int, 1);
pub const F_UNLCK = @as(c_int, 2);
pub const F_EXLCK = @as(c_int, 4);
pub const F_SHLCK = @as(c_int, 8);
pub const LOCK_SH = @as(c_int, 1);
pub const LOCK_EX = @as(c_int, 2);
pub const LOCK_NB = @as(c_int, 4);
pub const LOCK_UN = @as(c_int, 8);
pub const FAPPEND = O_APPEND;
pub const FFSYNC = O_FSYNC;
pub const FASYNC = O_ASYNC;
pub const FNONBLOCK = O_NONBLOCK;
pub const FNDELAY = O_NDELAY;
pub const __POSIX_FADV_DONTNEED = @as(c_int, 4);
pub const __POSIX_FADV_NOREUSE = @as(c_int, 5);
pub const POSIX_FADV_NORMAL = @as(c_int, 0);
pub const POSIX_FADV_RANDOM = @as(c_int, 1);
pub const POSIX_FADV_SEQUENTIAL = @as(c_int, 2);
pub const POSIX_FADV_WILLNEED = @as(c_int, 3);
pub const POSIX_FADV_DONTNEED = __POSIX_FADV_DONTNEED;
pub const POSIX_FADV_NOREUSE = __POSIX_FADV_NOREUSE;
pub const AT_FDCWD = -@as(c_int, 100);
pub const AT_SYMLINK_NOFOLLOW = @as(c_int, 0x100);
pub const AT_REMOVEDIR = @as(c_int, 0x200);
pub const AT_SYMLINK_FOLLOW = @as(c_int, 0x400);
pub const AT_EACCESS = @as(c_int, 0x200);
pub inline fn __OPEN_NEEDS_MODE(oflag: anytype) @TypeOf(((oflag & O_CREAT) != @as(c_int, 0)) or ((oflag & __O_TMPFILE) == __O_TMPFILE)) {
    _ = &oflag;
    return ((oflag & O_CREAT) != @as(c_int, 0)) or ((oflag & __O_TMPFILE) == __O_TMPFILE);
}
pub const _BITS_STAT_H = @as(c_int, 1);
pub const _BITS_STRUCT_STAT_H = @as(c_int, 1);
pub const _STATBUF_ST_BLKSIZE = "";
pub const _STATBUF_ST_RDEV = "";
pub const _STATBUF_ST_NSEC = "";
pub const __S_IFMT = std.zig.c_translation.promoteIntLiteral(c_int, 0o170000, .octal);
pub const __S_IFDIR = @as(c_int, 0o040000);
pub const __S_IFCHR = @as(c_int, 0o020000);
pub const __S_IFBLK = @as(c_int, 0o060000);
pub const __S_IFREG = std.zig.c_translation.promoteIntLiteral(c_int, 0o100000, .octal);
pub const __S_IFIFO = @as(c_int, 0o010000);
pub const __S_IFLNK = std.zig.c_translation.promoteIntLiteral(c_int, 0o120000, .octal);
pub const __S_IFSOCK = std.zig.c_translation.promoteIntLiteral(c_int, 0o140000, .octal);
pub inline fn __S_TYPEISMQ(buf: anytype) @TypeOf(buf.*.st_mode - buf.*.st_mode) {
    _ = &buf;
    return buf.*.st_mode - buf.*.st_mode;
}
pub inline fn __S_TYPEISSEM(buf: anytype) @TypeOf(buf.*.st_mode - buf.*.st_mode) {
    _ = &buf;
    return buf.*.st_mode - buf.*.st_mode;
}
pub inline fn __S_TYPEISSHM(buf: anytype) @TypeOf(buf.*.st_mode - buf.*.st_mode) {
    _ = &buf;
    return buf.*.st_mode - buf.*.st_mode;
}
pub const __S_ISUID = @as(c_int, 0o4000);
pub const __S_ISGID = @as(c_int, 0o2000);
pub const __S_ISVTX = @as(c_int, 0o1000);
pub const __S_IREAD = @as(c_int, 0o400);
pub const __S_IWRITE = @as(c_int, 0o200);
pub const __S_IEXEC = @as(c_int, 0o100);
pub const UTIME_NOW = (@as(c_long, 1) << @as(c_int, 30)) - @as(c_long, 1);
pub const UTIME_OMIT = (@as(c_long, 1) << @as(c_int, 30)) - @as(c_long, 2);
pub const S_IFMT = __S_IFMT;
pub const S_IFDIR = __S_IFDIR;
pub const S_IFCHR = __S_IFCHR;
pub const S_IFBLK = __S_IFBLK;
pub const S_IFREG = __S_IFREG;
pub const S_IFIFO = __S_IFIFO;
pub const S_IFLNK = __S_IFLNK;
pub const S_IFSOCK = __S_IFSOCK;
pub const S_ISUID = __S_ISUID;
pub const S_ISGID = __S_ISGID;
pub const S_ISVTX = __S_ISVTX;
pub const S_IRUSR = __S_IREAD;
pub const S_IWUSR = __S_IWRITE;
pub const S_IXUSR = __S_IEXEC;
pub const S_IRWXU = (__S_IREAD | __S_IWRITE) | __S_IEXEC;
pub const S_IRGRP = S_IRUSR >> @as(c_int, 3);
pub const S_IWGRP = S_IWUSR >> @as(c_int, 3);
pub const S_IXGRP = S_IXUSR >> @as(c_int, 3);
pub const S_IRWXG = S_IRWXU >> @as(c_int, 3);
pub const S_IROTH = S_IRGRP >> @as(c_int, 3);
pub const S_IWOTH = S_IWGRP >> @as(c_int, 3);
pub const S_IXOTH = S_IXGRP >> @as(c_int, 3);
pub const S_IRWXO = S_IRWXG >> @as(c_int, 3);
pub const R_OK = @as(c_int, 4);
pub const W_OK = @as(c_int, 2);
pub const X_OK = @as(c_int, 1);
pub const F_OK = @as(c_int, 0);
pub const SEEK_SET = @as(c_int, 0);
pub const SEEK_CUR = @as(c_int, 1);
pub const SEEK_END = @as(c_int, 2);
pub const F_ULOCK = @as(c_int, 0);
pub const F_LOCK = @as(c_int, 1);
pub const F_TLOCK = @as(c_int, 2);
pub const F_TEST = @as(c_int, 3);
pub const _TIME_H = @as(c_int, 1);
pub const __need_NULL = "";
pub const NULL = std.zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const _BITS_TIME_H = @as(c_int, 1);
pub const CLOCKS_PER_SEC = std.zig.c_translation.cast(clock_t, std.zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
pub const CLOCK_REALTIME = @as(c_int, 0);
pub const CLOCK_MONOTONIC = @as(c_int, 1);
pub const CLOCK_PROCESS_CPUTIME_ID = @as(c_int, 2);
pub const CLOCK_THREAD_CPUTIME_ID = @as(c_int, 3);
pub const CLOCK_MONOTONIC_RAW = @as(c_int, 4);
pub const CLOCK_REALTIME_COARSE = @as(c_int, 5);
pub const CLOCK_MONOTONIC_COARSE = @as(c_int, 6);
pub const CLOCK_BOOTTIME = @as(c_int, 7);
pub const CLOCK_REALTIME_ALARM = @as(c_int, 8);
pub const CLOCK_BOOTTIME_ALARM = @as(c_int, 9);
pub const CLOCK_TAI = @as(c_int, 11);
pub const TIMER_ABSTIME = @as(c_int, 1);
pub const __struct_tm_defined = @as(c_int, 1);
pub const __itimerspec_defined = @as(c_int, 1);
pub const _BITS_TYPES_LOCALE_T_H = @as(c_int, 1);
pub const _BITS_TYPES___LOCALE_T_H = @as(c_int, 1);
pub const TIME_UTC = @as(c_int, 1);
pub inline fn __isleap(year: anytype) @TypeOf((std.zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 4)) == @as(c_int, 0)) and ((std.zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 100)) != @as(c_int, 0)) or (std.zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 400)) == @as(c_int, 0)))) {
    _ = &year;
    return (std.zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 4)) == @as(c_int, 0)) and ((std.zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 100)) != @as(c_int, 0)) or (std.zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 400)) == @as(c_int, 0)));
}
pub const _SYS_STAT_H = @as(c_int, 1);
pub inline fn __S_ISTYPE(mode: anytype, mask: anytype) @TypeOf((mode & __S_IFMT) == mask) {
    _ = &mode;
    _ = &mask;
    return (mode & __S_IFMT) == mask;
}
pub inline fn S_ISDIR(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFDIR)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFDIR);
}
pub inline fn S_ISCHR(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFCHR)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFCHR);
}
pub inline fn S_ISBLK(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFBLK)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFBLK);
}
pub inline fn S_ISREG(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFREG)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFREG);
}
pub inline fn S_ISFIFO(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFIFO)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFIFO);
}
pub inline fn S_ISLNK(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFLNK)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFLNK);
}
pub inline fn S_ISSOCK(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFSOCK)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFSOCK);
}
pub inline fn S_TYPEISMQ(buf: anytype) @TypeOf(__S_TYPEISMQ(buf)) {
    _ = &buf;
    return __S_TYPEISMQ(buf);
}
pub inline fn S_TYPEISSEM(buf: anytype) @TypeOf(__S_TYPEISSEM(buf)) {
    _ = &buf;
    return __S_TYPEISSEM(buf);
}
pub inline fn S_TYPEISSHM(buf: anytype) @TypeOf(__S_TYPEISSHM(buf)) {
    _ = &buf;
    return __S_TYPEISSHM(buf);
}
pub const S_IREAD = S_IRUSR;
pub const S_IWRITE = S_IWUSR;
pub const S_IEXEC = S_IXUSR;
pub const ACCESSPERMS = (S_IRWXU | S_IRWXG) | S_IRWXO;
pub const ALLPERMS = ((((S_ISUID | S_ISGID) | S_ISVTX) | S_IRWXU) | S_IRWXG) | S_IRWXO;
pub const DEFFILEMODE = ((((S_IRUSR | S_IWUSR) | S_IRGRP) | S_IWGRP) | S_IROTH) | S_IWOTH;
pub const S_BLKSIZE = @as(c_int, 512);
pub const _SYS_STATVFS_H = @as(c_int, 1);
pub const _SYS_UIO_H = @as(c_int, 1);
pub const __iovec_defined = @as(c_int, 1);
pub const _BITS_UIO_LIM_H = @as(c_int, 1);
pub const __IOV_MAX = @as(c_int, 1024);
pub const UIO_MAXIOV = __IOV_MAX;

pub const dev_t = linux.dev_t;
pub const ino_t = linux.ino_t;
pub const mode_t = linux.mode_t;
pub const nlink_t = linux.nlink_t;
pub const uid_t = linux.uid_t;
pub const gid_t = linux.gid_t;
pub const off_t = linux.off_t;
pub const blksize_t = linux.blksize_t;
pub const blkcnt_t = linux.blkcnt_t;
pub const timespec = linux.timespec;
pub const pid_t = linux.pid_t;
pub const clock_t = linux.clock_t;
pub const Flock = linux.Flock;
// Not sure here
pub const __syscall_slong_t = i64;

// manually added
pub const stat = extern struct {
    st_dev: dev_t = std.mem.zeroes(dev_t),
    st_ino: ino_t = std.mem.zeroes(ino_t),
    st_nlink: nlink_t = std.mem.zeroes(nlink_t),
    st_mode: mode_t = std.mem.zeroes(mode_t),
    st_uid: uid_t = std.mem.zeroes(uid_t),
    st_gid: gid_t = std.mem.zeroes(gid_t),
    __pad0: c_int = std.mem.zeroes(c_int),
    st_rdev: dev_t = std.mem.zeroes(dev_t),
    st_size: off_t = std.mem.zeroes(off_t),
    st_blksize: blksize_t = std.mem.zeroes(blksize_t),
    st_blocks: blkcnt_t = std.mem.zeroes(blkcnt_t),
    st_atim: timespec = std.mem.zeroes(timespec),
    st_mtim: timespec = std.mem.zeroes(timespec),
    st_ctim: timespec = std.mem.zeroes(timespec),
    __glibc_reserved: [3]__syscall_slong_t = std.mem.zeroes([3]__syscall_slong_t),
};

// manually added
pub const fuse_opt = extern struct {
    templ: [*c]const u8 = std.mem.zeroes([*c]const u8),
    offset: c_ulong = std.mem.zeroes(c_ulong),
    value: c_int = std.mem.zeroes(c_int),
};
pub const fuse_args = extern struct {
    argc: c_int = std.mem.zeroes(c_int),
    argv: [*c][*c]u8 = std.mem.zeroes([*c][*c]u8),
    allocated: c_int = std.mem.zeroes(c_int),
};

// manually added
/// Information about an open file.
///
/// File Handles are created by the open, opendir, and create methods and closed by the release and releasedir methods. Multiple file handles may be concurrently open for the same file. Generally, a client will create one file handle per file descriptor, though in some cases multiple file descriptors can share a single file handle.
pub const fuse_file_info_packed = packed struct { flags: c_int, writepage: u1, direct_io: u1, keep_cache: u1, parallel_direct_writes: u1, flush: u1, nonseekable: u1, cache_readdir: u1, noflush: u1, padding: u23, idk: u33, fh: c_ulong, lock_owner: c_ulong, poll_events: c_uint };

pub const fuse_file_info = extern struct { flags: c_int, padding: u32, fh: c_ulong, lock_owner: c_ulong, poll_events: c_uint };

pub const fuse_loop_config_v1 = extern struct {
    clone_fd: c_int = std.mem.zeroes(c_int),
    max_idle_threads: c_uint = std.mem.zeroes(c_uint),
};
pub const fuse_conn_info = extern struct {
    proto_major: c_uint = std.mem.zeroes(c_uint),
    proto_minor: c_uint = std.mem.zeroes(c_uint),
    max_write: c_uint = std.mem.zeroes(c_uint),
    max_read: c_uint = std.mem.zeroes(c_uint),
    max_readahead: c_uint = std.mem.zeroes(c_uint),
    capable: c_uint = std.mem.zeroes(c_uint),
    want: c_uint = std.mem.zeroes(c_uint),
    max_background: c_uint = std.mem.zeroes(c_uint),
    congestion_threshold: c_uint = std.mem.zeroes(c_uint),
    time_gran: c_uint = std.mem.zeroes(c_uint),
    reserved: [22]c_uint = std.mem.zeroes([22]c_uint),
};
pub const fuse_session = opaque {};
pub const fuse_pollhandle = opaque {};
pub const fuse_conn_info_opts = opaque {};

const __fsblkcnt64_t = u64;
const __fsfilcnt64_t = u64;

// manually added
pub const statvfs = extern struct {
    f_bsize: c_ulong = std.mem.zeroes(c_ulong),
    f_frsize: c_ulong = std.mem.zeroes(c_ulong),
    f_blocks: __fsblkcnt64_t = std.mem.zeroes(__fsblkcnt64_t),
    f_bfree: __fsblkcnt64_t = std.mem.zeroes(__fsblkcnt64_t),
    f_bavail: __fsblkcnt64_t = std.mem.zeroes(__fsblkcnt64_t),
    f_files: __fsfilcnt64_t = std.mem.zeroes(__fsfilcnt64_t),
    f_ffree: __fsfilcnt64_t = std.mem.zeroes(__fsfilcnt64_t),
    f_favail: __fsfilcnt64_t = std.mem.zeroes(__fsfilcnt64_t),
    f_fsid: c_ulong = std.mem.zeroes(c_ulong),
    f_flag: c_ulong = std.mem.zeroes(c_ulong),
    f_namemax: c_ulong = std.mem.zeroes(c_ulong),
    __f_spare: [6]c_int = std.mem.zeroes([6]c_int),
};

pub const fuse_loop_config = opaque {};

// manually added
pub const enum_fuse_buf_flags = c_uint;
//pub const enum_fuse_readdir_flags = c_uint;
pub const fuse_buf = extern struct {
    size: usize = std.mem.zeroes(usize),
    flags: enum_fuse_buf_flags = std.mem.zeroes(enum_fuse_buf_flags),
    mem: ?*anyopaque = std.mem.zeroes(?*anyopaque),
    fd: c_int = std.mem.zeroes(c_int),
    pos: off_t = std.mem.zeroes(off_t),
};

// manually added
pub const fuse_bufvec = extern struct {
    count: usize = std.mem.zeroes(usize),
    idx: usize = std.mem.zeroes(usize),
    off: usize = std.mem.zeroes(usize),
    buf: [1]fuse_buf = std.mem.zeroes([1]fuse_buf),
};

/// Handle for a FUSE filesystem
pub const fuse = extern struct {};

/// Readdir flags, passed to ->readdir()
pub const fuse_readdir_flags = extern struct {
    bits: c_int = 0,

    /// "Plus" mode.
    ///
    /// The kernel wants to prefill the inode cache during readdir.  The
    /// filesystem may honour this by filling in the attributes and setting
    /// FUSE_FILL_DIR_FLAGS for the filler function.  The filesystem may also
    /// just ignore this flag completely.
    pub const FUSE_READDIR_PLUS: fuse_readdir_flags = .{ .bits = @as(c_uint, @intCast((1 << 0))) };

    // pub usingnamespace cpp.FlagsMixin(fuse_readdir_flags);
};

/// Readdir flags, passed to fuse_fill_dir_t callback.
pub const fuse_fill_dir_flags = extern struct {
    bits: c_int = 0,

    /// "Plus" mode: all file attributes are valid
    ///
    /// The attributes are used by the kernel to prefill the inode cache
    /// during a readdir.
    ///
    /// It is okay to set FUSE_FILL_DIR_PLUS if FUSE_READDIR_PLUS is not set
    /// and vice versa.
    pub const FUSE_FILL_DIR_PLUS: fuse_fill_dir_flags = .{ .bits = @as(c_uint, @intCast((1 << 1))) };

    // pub usingnamespace cpp.FlagsMixin(fuse_fill_dir_flags);
};

/// Function to add an entry in a readdir() operation
///
/// The *off* parameter can be any non-zero value that enables the
/// filesystem to identify the current point in the directory
/// stream. It does not need to be the actual physical position. A
/// value of zero is reserved to indicate that seeking in directories
/// is not supported.
///
/// @param[in] buf  the buffer passed to the readdir() operation
/// @param[in] name  the file name of the directory entry
/// @param[in] stbuf  file attributes, can be NULL
/// @param[in] off  offset of the next entry or zero
/// @param[in] flags  fill flags
/// @see 1 if buffer is full, zero otherwise
pub const fuse_fill_dir_t = ?*const fn (?*anyopaque, [*c]const u8, [*c]const stat, off_t, fuse_fill_dir_flags) callconv(.C) c_int;

/// Configuration of the high-level API
///
/// This structure is initialized from the arguments passed to
/// fuse_new(), and then passed to the file system's init() handler
/// which should ensure that the configuration is compatible with the
/// file system implementation.
pub const fuse_config = extern struct {
    /// If `set_gid` is non-zero, the st_gid attribute of each file
    /// is overwritten with the value of `gid`.
    set_gid: c_int,
    gid: c_uint,
    /// If `set_uid` is non-zero, the st_uid attribute of each file
    /// is overwritten with the value of `uid`.
    set_uid: c_int,
    uid: c_uint,
    /// If `set_mode` is non-zero, the any permissions bits set in
    /// `umask` are unset in the st_mode attribute of each file.
    set_mode: c_int,
    umask: c_uint,
    /// The timeout in seconds for which name lookups will be
    /// cached.
    entry_timeout: f64,
    /// The timeout in seconds for which a negative lookup will be
    /// cached. This means, that if file did not exist (lookup
    /// returned ENOENT), the lookup will only be redone after the
    /// timeout, and the file/directory will be assumed to not
    /// exist until then. A value of zero means that negative
    /// lookups are not cached.
    negative_timeout: f64,
    /// The timeout in seconds for which file/directory attributes
    /// (as returned by e.g. the `getattr` handler) are cached.
    attr_timeout: f64,
    /// Allow requests to be interrupted
    intr: c_int,
    /// Specify which signal number to send to the filesystem when
    /// a request is interrupted.  The default is hardcoded to
    /// USR1.
    intr_signal: c_int,
    /// Normally, FUSE assigns inodes to paths only for as long as
    /// the kernel is aware of them. With this option inodes are
    /// instead remembered for at least this many seconds.  This
    /// will require more memory, but may be necessary when using
    /// applications that make use of inode numbers.
    ///
    /// A number of -1 means that inodes will be remembered for the
    /// entire life-time of the file-system process.
    remember: c_int,
    /// The default behavior is that if an open file is deleted,
    /// the file is renamed to a hidden file (.fuse_hiddenXXX), and
    /// only removed when the file is finally released.  This
    /// relieves the filesystem implementation of having to deal
    /// with this problem. This option disables the hiding
    /// behavior, and files are removed immediately in an unlink
    /// operation (or in a rename operation which overwrites an
    /// existing file).
    ///
    /// It is recommended that you not use the hard_remove
    /// option. When hard_remove is set, the following libc
    /// functions fail on unlinked files (returning errno of
    /// ENOENT): read(2), write(2), fsync(2), close(2), f*xattr(2),
    /// ftruncate(2), fstat(2), fchmod(2), fchown(2)
    hard_remove: c_int,
    /// Honor the st_ino field in the functions getattr() and
    /// fill_dir(). This value is used to fill in the st_ino field
    /// in the stat(2), lstat(2), fstat(2) functions and the d_ino
    /// field in the readdir(2) function. The filesystem does not
    /// have to guarantee uniqueness, however some applications
    /// rely on this value being unique for the whole filesystem.
    ///
    /// Note that this does *not* affect the inode that libfuse
    /// and the kernel use internally (also called the "nodeid").
    use_ino: c_int,
    /// If use_ino option is not given, still try to fill in the
    /// d_ino field in readdir(2). If the name was previously
    /// looked up, and is still in the cache, the inode number
    /// found there will be used.  Otherwise it will be set to -1.
    /// If use_ino option is given, this option is ignored.
    readdir_ino: c_int,
    /// This option disables the use of page cache (file content cache)
    /// in the kernel for this filesystem. This has several affects:
    ///
    /// 1. Each read(2) or write(2) system call will initiate one
    ///    or more read or write operations, data will not be
    ///    cached in the kernel.
    ///
    /// 2. The return value of the read() and write() system calls
    ///    will correspond to the return values of the read and
    ///    write operations. This is useful for example if the
    ///    file size is not known in advance (before reading it).
    ///
    /// Internally, enabling this option causes fuse to set the
    /// `direct_io` field of `struct fuse_file_info` - overwriting
    /// any value that was put there by the file system.
    direct_io: c_int,
    /// This option disables flushing the cache of the file
    /// contents on every open(2).  This should only be enabled on
    /// filesystems where the file data is never changed
    /// externally (not through the mounted FUSE filesystem).  Thus
    /// it is not suitable for network filesystems and other
    /// intermediate filesystems.
    ///
    /// NOTE: if this option is not specified (and neither
    /// direct_io) data is still cached after the open(2), so a
    /// read(2) system call will not always initiate a read
    /// operation.
    ///
    /// Internally, enabling this option causes fuse to set the
    /// `keep_cache` field of `struct fuse_file_info` - overwriting
    /// any value that was put there by the file system.
    kernel_cache: c_int,
    /// This option is an alternative to `kernel_cache`. Instead of
    /// unconditionally keeping cached data, the cached data is
    /// invalidated on open(2) if if the modification time or the
    /// size of the file has changed since it was last opened.
    auto_cache: c_int,
    /// By default, fuse waits for all pending writes to complete
    /// and calls the FLUSH operation on close(2) of every fuse fd.
    /// With this option, wait and FLUSH are not done for read-only
    /// fuse fd, similar to the behavior of NFS/SMB clients.
    no_rofd_flush: c_int,
    /// The timeout in seconds for which file attributes are cached
    /// for the purpose of checking if auto_cache should flush the
    /// file data on open.
    ac_attr_timeout_set: c_int,
    ac_attr_timeout: f64,
    /// If this option is given the file-system handlers for the
    /// following operations will not receive path information:
    /// read, write, flush, release, fallocate, fsync, readdir,
    /// releasedir, fsyncdir, lock, ioctl and poll.
    ///
    /// For the truncate, getattr, chmod, chown and utimens
    /// operations the path will be provided only if the struct
    /// fuse_file_info argument is NULL.
    nullpath_ok: c_int,
    ///  Allow parallel direct-io writes to operate on the same file.
    ///
    ///  FUSE implementations which do not handle parallel writes on
    ///  same file/region should NOT enable this option at all as it
    ///  might lead to data inconsistencies.
    ///
    ///  For the FUSE implementations which have their own mechanism
    ///  of cache/data integrity are beneficiaries of this setting as
    ///  it now open doors to parallel writes on the same file (without
    ///  enabling this setting, all direct writes on the same file are
    ///  serialized, resulting in huge data bandwidth loss).
    parallel_direct_writes: c_int,
    /// The remaining options are used by libfuse internally and
    /// should not be touched.
    show_help: c_int,
    modules: [*c]u8,
    debug: c_int,
};

/// The file system operations:
///
/// Most of these should work very similarly to the well known UNIX
/// file system operations.  A major exception is that instead of
/// returning an error in 'errno', the operation should return the
/// negated error value (-errno) directly.
///
/// All methods are optional, but some are essential for a useful
/// filesystem (e.g. getattr).  Open, flush, release, fsync, opendir,
/// releasedir, fsyncdir, access, create, truncate, lock, init and
/// destroy are special purpose methods, without which a full featured
/// filesystem can still be implemented.
///
/// In general, all methods are expected to perform any necessary
/// permission checking. However, a filesystem may delegate this task
/// to the kernel by passing the `default_permissions` mount option to
/// `fuse_new()`. In this case, methods will only be called if
/// the kernel's permission check has succeeded.
///
/// Almost all operations take a path which can be of any length.
pub const fuse_operations = extern struct {
    /// Get file attributes.
    ///
    /// Similar to stat().  The 'st_dev' and 'st_blksize' fields are
    /// ignored. The 'st_ino' field is ignored except if the 'use_ino'
    /// mount option is given. In that case it is passed to userspace,
    /// but libfuse and the kernel will still assign a different
    /// inode for internal use (called the "nodeid").
    ///
    /// `fi` will always be NULL if the file is not currently open, but
    /// may also be NULL if the file is open.
    getattr: ?*const fn ([*c]const u8, ?*stat, ?*fuse_file_info) callconv(.C) c_int,
    /// Read the target of a symbolic link
    ///
    /// The buffer should be filled with a null terminated string.  The
    /// buffer size argument includes the space for the terminating
    /// null character.	If the linkname is too long to fit in the
    /// buffer, it should be truncated.	The return value should be 0
    /// for success.
    readlink: ?*const fn ([*c]const u8, [*c]u8, usize) callconv(.C) c_int,
    /// Create a file node
    ///
    /// This is called for creation of all non-directory, non-symlink
    /// nodes.  If the filesystem defines a create() method, then for
    /// regular files that will be called instead.
    mknod: ?*const fn ([*c]const u8, mode_t, dev_t) callconv(.C) c_int,
    /// Create a directory
    ///
    /// Note that the mode argument may not have the type specification
    /// bits set, i.e. S_ISDIR(mode) can be false.  To obtain the
    /// correct directory type bits use  mode|S_IFDIR
    mkdir: ?*const fn ([*c]const u8, mode_t) callconv(.C) c_int,
    /// Remove a file
    unlink: ?*const fn ([*c]const u8) callconv(.C) c_int,
    /// Remove a directory
    rmdir: ?*const fn ([*c]const u8) callconv(.C) c_int,
    /// Create a symbolic link
    symlink: ?*const fn ([*c]const u8, [*c]const u8) callconv(.C) c_int,
    /// Rename a file
    ///
    /// *flags* may be `RENAME_EXCHANGE` or `RENAME_NOREPLACE`. If
    /// RENAME_NOREPLACE is specified, the filesystem must not
    /// overwrite *newname* if it exists and return an error
    /// instead. If `RENAME_EXCHANGE` is specified, the filesystem
    /// must atomically exchange the two files, i.e. both must
    /// exist and neither may be deleted.
    rename: ?*const fn ([*c]const u8, [*c]const u8, c_uint) callconv(.C) c_int,
    /// Create a hard link to a file
    link: ?*const fn ([*c]const u8, [*c]const u8) callconv(.C) c_int,
    /// Change the permission bits of a file
    ///
    /// `fi` will always be NULL if the file is not currently open, but
    /// may also be NULL if the file is open.
    chmod: ?*const fn ([*c]const u8, mode_t, [*c]fuse_file_info) callconv(.C) c_int,
    /// Change the owner and group of a file
    ///
    /// `fi` will always be NULL if the file is not currently open, but
    /// may also be NULL if the file is open.
    ///
    /// Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is
    /// expected to reset the setuid and setgid bits.
    chown: ?*const fn ([*c]const u8, uid_t, gid_t, [*c]fuse_file_info) callconv(.C) c_int,
    /// Change the size of a file
    ///
    /// `fi` will always be NULL if the file is not currently open, but
    /// may also be NULL if the file is open.
    ///
    /// Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is
    /// expected to reset the setuid and setgid bits.
    truncate: ?*const fn ([*c]const u8, off_t, [*c]fuse_file_info) callconv(.C) c_int,
    /// Open a file
    ///
    /// Open flags are available in fi->flags. The following rules
    /// apply.
    ///
    ///  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be
    ///    filtered out / handled by the kernel.
    ///
    ///  - Access modes (O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, O_SEARCH)
    ///    should be used by the filesystem to check if the operation is
    ///    permitted.  If the ``-o default_permissions`` mount option is
    ///    given, this check is already done by the kernel before calling
    ///    open() and may thus be omitted by the filesystem.
    ///
    ///  - When writeback caching is enabled, the kernel may send
    ///    read requests even for files opened with O_WRONLY. The
    ///    filesystem should be prepared to handle this.
    ///
    ///  - When writeback caching is disabled, the filesystem is
    ///    expected to properly handle the O_APPEND flag and ensure
    ///    that each write is appending to the end of the file.
    ///
    ///  - When writeback caching is enabled, the kernel will
    ///    handle O_APPEND. However, unless all changes to the file
    ///    come through the kernel this will not work reliably. The
    ///    filesystem should thus either ignore the O_APPEND flag
    ///    (and let the kernel handle it), or return an error
    ///    (indicating that reliably O_APPEND is not available).
    ///
    /// Filesystem may store an arbitrary file handle (pointer,
    /// index, etc) in fi->fh, and use this in other all other file
    /// operations (read, write, flush, release, fsync).
    ///
    /// Filesystem may also implement stateless file I/O and not store
    /// anything in fi->fh.
    ///
    /// There are also some flags (direct_io, keep_cache) which the
    /// filesystem may set in fi, to change the way the file is opened.
    /// See fuse_file_info structure in
    ///<fuse
    ///_common.h> for more details.
    ///
    /// If this request is answered with an error code of ENOSYS
    /// and FUSE_CAP_NO_OPEN_SUPPORT is set in
    /// `fuse_conn_info.capable`, this is treated as success and
    /// future calls to open will also succeed without being sent
    /// to the filesystem process.
    ///
    ///
    open: ?*const fn ([*c]const u8, *fuse_file_info) callconv(.C) c_int,
    /// Read data from an open file
    ///
    /// Read should return exactly the number of bytes requested except
    /// on EOF or error, otherwise the rest of the data will be
    /// substituted with zeroes.	 An exception to this is when the
    /// 'direct_io' mount option is specified, in which case the return
    /// value of the read system call will reflect the return value of
    /// this operation.
    read: ?*const fn ([*c]const u8, [*c]u8, usize, off_t, ?*fuse_file_info) callconv(.C) c_int,
    /// Write data to an open file
    ///
    /// Write should return exactly the number of bytes requested
    /// except on error.	 An exception to this is when the 'direct_io'
    /// mount option is specified (see read operation).
    ///
    /// Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is
    /// expected to reset the setuid and setgid bits.
    write: ?*const fn ([*c]const u8, [*c]const u8, usize, off_t, [*c]fuse_file_info) callconv(.C) c_int,
    /// Get file system statistics
    ///
    /// The 'f_favail', 'f_fsid' and 'f_flag' fields are ignored
    statfs: ?*const fn ([*c]const u8, [*c]statvfs) callconv(.C) c_int,
    /// Possibly flush cached data
    ///
    /// BIG NOTE: This is not equivalent to fsync().  It's not a
    /// request to sync dirty data.
    ///
    /// Flush is called on each close() of a file descriptor, as opposed to
    /// release which is called on the close of the last file descriptor for
    /// a file.  Under Linux, errors returned by flush() will be passed to
    /// userspace as errors from close(), so flush() is a good place to write
    /// back any cached dirty data. However, many applications ignore errors
    /// on close(), and on non-Linux systems, close() may succeed even if flush()
    /// returns an error. For these reasons, filesystems should not assume
    /// that errors returned by flush will ever be noticed or even
    /// delivered.
    ///
    /// NOTE: The flush() method may be called more than once for each
    /// open().  This happens if more than one file descriptor refers to an
    /// open file handle, e.g. due to dup(), dup2() or fork() calls.  It is
    /// not possible to determine if a flush is final, so each flush should
    /// be treated equally.  Multiple write-flush sequences are relatively
    /// rare, so this shouldn't be a problem.
    ///
    /// Filesystems shouldn't assume that flush will be called at any
    /// particular point.  It may be called more times than expected, or not
    /// at all.
    ///
    /// [close]: http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html
    flush: ?*const fn ([*c]const u8, [*c]fuse_file_info) callconv(.C) c_int,
    /// Release an open file
    ///
    /// Release is called when there are no more references to an open
    /// file: all file descriptors are closed and all memory mappings
    /// are unmapped.
    ///
    /// For every open() call there will be exactly one release() call
    /// with the same flags and file handle.  It is possible to
    /// have a file opened more than once, in which case only the last
    /// release will mean, that no more reads/writes will happen on the
    /// file.  The return value of release is ignored.
    release: ?*const fn ([*c]const u8, [*c]fuse_file_info) callconv(.C) c_int,
    /// Synchronize file contents
    ///
    /// If the datasync parameter is non-zero, then only the user data
    /// should be flushed, not the meta data.
    fsync: ?*const fn ([*c]const u8, c_int, [*c]fuse_file_info) callconv(.C) c_int,
    /// Set extended attributes
    setxattr: ?*const fn ([*c]const u8, [*c]const u8, [*c]const u8, usize, c_int) callconv(.C) c_int,
    /// Get extended attributes
    getxattr: ?*const fn ([*c]const u8, [*c]const u8, [*c]u8, usize) callconv(.C) c_int,
    /// List extended attributes
    listxattr: ?*const fn ([*c]const u8, [*c]u8, usize) callconv(.C) c_int,
    /// Remove extended attributes
    removexattr: ?*const fn ([*c]const u8, [*c]const u8) callconv(.C) c_int,
    /// Open directory
    ///
    /// Unless the 'default_permissions' mount option is given,
    /// this method should check if opendir is permitted for this
    /// directory. Optionally opendir may also return an arbitrary
    /// filehandle in the fuse_file_info structure, which will be
    /// passed to readdir, releasedir and fsyncdir.
    opendir: ?*const fn ([*c]const u8, [*c]fuse_file_info) callconv(.C) c_int,
    /// Read directory
    ///
    /// The filesystem may choose between two modes of operation:
    ///
    /// 1) The readdir implementation ignores the offset parameter, and
    /// passes zero to the filler function's offset.  The filler
    /// function will not return '1' (unless an error happens), so the
    /// whole directory is read in a single readdir operation.
    ///
    /// 2) The readdir implementation keeps track of the offsets of the
    /// directory entries.  It uses the offset parameter and always
    /// passes non-zero offset to the filler function.  When the buffer
    /// is full (or an error happens) the filler function will return
    /// '1'.
    ///
    /// When FUSE_READDIR_PLUS is not set, only some parameters of the
    /// fill function (the fuse_fill_dir_t parameter) are actually used:
    /// The file type (which is part of stat::st_mode) is used. And if
    /// fuse_config::use_ino is set, the inode (stat::st_ino) is also
    /// used. The other fields are ignored when FUSE_READDIR_PLUS is not
    /// set.
    readdir: ?*const fn ([*c]const u8, ?*anyopaque, fuse_fill_dir_t, off_t, ?*fuse_file_info, fuse_readdir_flags) callconv(.C) c_int,
    /// Release directory
    ///
    /// If the directory has been removed after the call to opendir, the
    /// path parameter will be NULL.
    releasedir: ?*const fn ([*c]const u8, [*c]fuse_file_info) callconv(.C) c_int,
    /// Synchronize directory contents
    ///
    /// If the directory has been removed after the call to opendir, the
    /// path parameter will be NULL.
    ///
    /// If the datasync parameter is non-zero, then only the user data
    /// should be flushed, not the meta data
    fsyncdir: ?*const fn ([*c]const u8, c_int, [*c]fuse_file_info) callconv(.C) c_int,
    /// Initialize filesystem
    ///
    /// The return value will passed in the `private_data` field of
    /// `struct fuse_context` to all file operations, and as a
    /// parameter to the destroy() method. It overrides the initial
    /// value provided to fuse_main() / fuse_new().
    init: ?*const fn ([*c]fuse_conn_info, [*c]fuse_config) callconv(.C) ?*anyopaque,
    /// Clean up filesystem
    ///
    /// Called on filesystem exit.
    destroy: ?*const fn (?*anyopaque) callconv(.C) void,
    /// Check file access permissions
    ///
    /// This will be called for the access() system call.  If the
    /// 'default_permissions' mount option is given, this method is not
    /// called.
    ///
    /// This method is not called under Linux kernel versions 2.4.x
    access: ?*const fn ([*c]const u8, c_int) callconv(.C) c_int,
    /// Create and open a file
    ///
    /// If the file does not exist, first create it with the specified
    /// mode, and then open it.
    ///
    /// If this method is not implemented or under Linux kernel
    /// versions earlier than 2.6.15, the mknod() and open() methods
    /// will be called instead.
    create: ?*const fn ([*c]const u8, mode_t, [*c]fuse_file_info) callconv(.C) c_int,
    /// Perform POSIX file locking operation
    ///
    /// The cmd argument will be either F_GETLK, F_SETLK or F_SETLKW.
    ///
    /// For the meaning of fields in 'struct flock' see the man page
    /// for fcntl(2).  The l_whence field will always be set to
    /// SEEK_SET.
    ///
    /// For checking lock ownership, the 'fuse_file_info->owner'
    /// argument must be used.
    ///
    /// For F_GETLK operation, the library will first check currently
    /// held locks, and if a conflicting lock is found it will return
    /// information without calling this method.	 This ensures, that
    /// for local locks the l_pid field is correctly filled in.	The
    /// results may not be accurate in case of race conditions and in
    /// the presence of hard links, but it's unlikely that an
    /// application would rely on accurate GETLK results in these
    /// cases.  If a conflicting lock is not found, this method will be
    /// called, and the filesystem may fill out l_pid by a meaningful
    /// value, or it may leave this field zero.
    ///
    /// For F_SETLK and F_SETLKW the l_pid field will be set to the pid
    /// of the process performing the locking operation.
    ///
    /// Note: if this method is not implemented, the kernel will still
    /// allow file locking to work locally.  Hence it is only
    /// interesting for network filesystems and similar.
    lock: ?*const fn ([*c]const u8, [*c]fuse_file_info, c_int, [*c]Flock) callconv(.C) c_int,
    /// Change the access and modification times of a file with
    /// nanosecond resolution
    ///
    /// This supersedes the old utime() interface.  New applications
    /// should use this.
    ///
    /// `fi` will always be NULL if the file is not currently open, but
    /// may also be NULL if the file is open.
    ///
    /// See the utimensat(2) man page for details.
    utimens: ?*const fn ([*c]const u8, [*c]const timespec, [*c]fuse_file_info) callconv(.C) c_int,
    /// Map block index within file to block index within device
    ///
    /// Note: This makes sense only for block device backed filesystems
    /// mounted with the 'blkdev' option
    bmap: ?*const fn ([*c]const u8, usize, [*c]u64) callconv(.C) c_int,
    /// Ioctl
    ///
    /// flags will have FUSE_IOCTL_COMPAT set for 32bit ioctls in
    /// 64bit environment.  The size and direction of data is
    /// determined by _IOC_*() decoding of cmd.  For _IOC_NONE,
    /// data will be NULL, for _IOC_WRITE data is out area, for
    /// _IOC_READ in area and if both are set in/out area.  In all
    /// non-NULL cases, the area is of _IOC_SIZE(cmd) bytes.
    ///
    /// If flags has FUSE_IOCTL_DIR then the fuse_file_info refers to a
    /// directory file handle.
    ///
    /// Note : the unsigned long request submitted by the application
    /// is truncated to 32 bits.
    ioctl: ?*const fn ([*c]const u8, c_uint, ?*anyopaque, [*c]fuse_file_info, c_uint, ?*anyopaque) callconv(.C) c_int,
    /// Poll for IO readiness events
    ///
    /// Note: If ph is non-NULL, the client should notify
    /// when IO readiness events occur by calling
    /// fuse_notify_poll() with the specified ph.
    ///
    /// Regardless of the number of times poll with a non-NULL ph
    /// is received, single notification is enough to clear all.
    /// Notifying more times incurs overhead but doesn't harm
    /// correctness.
    ///
    /// The callee is responsible for destroying ph with
    /// fuse_pollhandle_destroy() when no longer in use.
    poll: ?*const fn ([*c]const u8, [*c]fuse_file_info, ?*fuse_pollhandle, [*c]c_uint) callconv(.C) c_int,
    /// Write contents of buffer to an open file
    ///
    /// Similar to the write() method, but data is supplied in a
    /// generic buffer.  Use fuse_buf_copy() to transfer data to
    /// the destination.
    ///
    /// Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is
    /// expected to reset the setuid and setgid bits.
    write_buf: ?*const fn ([*c]const u8, [*c]fuse_bufvec, off_t, [*c]fuse_file_info) callconv(.C) c_int,
    /// Store data from an open file in a buffer
    ///
    /// Similar to the read() method, but data is stored and
    /// returned in a generic buffer.
    ///
    /// No actual copying of data has to take place, the source
    /// file descriptor may simply be stored in the buffer for
    /// later data transfer.
    ///
    /// The buffer must be allocated dynamically and stored at the
    /// location pointed to by bufp.  If the buffer contains memory
    /// regions, they too must be allocated using malloc().  The
    /// allocated memory will be freed by the caller.
    read_buf: ?*const fn ([*c]const u8, [*c][*c]fuse_bufvec, usize, off_t, [*c]fuse_file_info) callconv(.C) c_int,
    /// Perform BSD file locking operation
    ///
    /// The op argument will be either LOCK_SH, LOCK_EX or LOCK_UN
    ///
    /// Nonblocking requests will be indicated by ORing LOCK_NB to
    /// the above operations
    ///
    /// For more information see the flock(2) manual page.
    ///
    /// Additionally fi->owner will be set to a value unique to
    /// this open file.  This same value will be supplied to
    /// ->release() when the file is released.
    ///
    /// Note: if this method is not implemented, the kernel will still
    /// allow file locking to work locally.  Hence it is only
    /// interesting for network filesystems and similar.
    flock: ?*const fn ([*c]const u8, [*c]fuse_file_info, c_int) callconv(.C) c_int,
    /// Allocates space for an open file
    ///
    /// This function ensures that required space is allocated for specified
    /// file.  If this function returns success then any subsequent write
    /// request to specified range is guaranteed not to fail because of lack
    /// of space on the file system media.
    fallocate: ?*const fn ([*c]const u8, c_int, off_t, off_t, [*c]fuse_file_info) callconv(.C) c_int,
    /// Copy a range of data from one file to another
    ///
    /// Performs an optimized copy between two file descriptors without the
    /// additional cost of transferring data through the FUSE kernel module
    /// to user space (glibc) and then back into the FUSE filesystem again.
    ///
    /// In case this method is not implemented, applications are expected to
    /// fall back to a regular file copy.   (Some glibc versions did this
    /// emulation automatically, but the emulation has been removed from all
    /// glibc release branches.)
    copy_file_range: ?*const fn ([*c]const u8, [*c]fuse_file_info, off_t, [*c]const u8, [*c]fuse_file_info, off_t, usize, c_int) callconv(.C) isize,
    /// Find next data or hole after the specified offset
    lseek: ?*const fn ([*c]const u8, off_t, c_int, [*c]fuse_file_info) callconv(.C) off_t,
};

/// Extra context that may be needed by some filesystems
///
/// The uid, gid and pid fields are not filled in case of a writepage
/// operation.
pub const fuse_context = extern struct {
    /// Pointer to the fuse object
    fuse: [*c]fuse,
    /// User ID of the calling process
    uid: uid_t,
    /// Group ID of the calling process
    gid: gid_t,
    /// Process ID of the calling thread
    pid: pid_t,
    /// Private filesystem data
    private_data: ?*anyopaque,
    /// Umask of the calling process
    umask: mode_t,
};

/// Print available options (high- and low-level) to stdout.  This is
/// not an exhaustive list, but includes only those options that may be
/// of interest to an end-user of a file system.
///
/// The function looks at the argument vector only to determine if
/// there are additional modules to be loaded (module=foo option),
/// and attempts to call their help functions as well.
///
/// @param[in] args  the argument vector.
pub extern fn fuse_lib_help(args: [*c]fuse_args) void;
pub extern fn fuse_new(args: [*c]fuse_args, op: [*c]const fuse_operations, op_size: usize, private_data: ?*anyopaque) [*c]fuse;
/// Mount a FUSE file system.
///
/// @param[in] mountpoint  the mount point path
/// @param[in] f  the FUSE handle
///
/// @see 0 on success, -1 on failure.
pub extern fn fuse_mount(f: [*c]fuse, mountpoint: [*c]const u8) c_int;
/// Unmount a FUSE file system.
///
/// See fuse_session_unmount() for additional information.
///
/// @param[in] f  the FUSE handle
pub extern fn fuse_unmount(f: [*c]fuse) void;
/// Destroy the FUSE handle.
///
/// NOTE: This function does not unmount the filesystem.	 If this is
/// needed, call fuse_unmount() before calling this function.
///
/// @param[in] f  the FUSE handle
pub extern fn fuse_destroy(f: [*c]fuse) void;
/// FUSE event loop.
///
/// Requests from the kernel are processed, and the appropriate
/// operations are called.
///
/// For a description of the return value and the conditions when the
/// event loop exits, refer to the documentation of
/// fuse_session_loop().
///
/// @param[in] f  the FUSE handle
/// @see see fuse_session_loop()
///
/// See also: fuse_loop_mt()
pub extern fn fuse_loop(f: [*c]fuse) c_int;
/// Flag session as terminated
///
/// This function will cause any running event loops to exit on
/// the next opportunity.
///
/// @param[in] f  the FUSE handle
pub extern fn fuse_exit(f: [*c]fuse) void;
pub extern fn fuse_loop_mt(f: [*c]fuse, config: [*c]fuse_loop_config) c_int;
/// Get the current context
///
/// The context is only valid for the duration of a filesystem
/// operation, and thus must not be stored and used later.
///
/// @see the context
pub extern fn fuse_get_context() [*c]fuse_context;
/// Get the current supplementary group IDs for the current request
///
/// Similar to the getgroups(2) system call, except the return value is
/// always the total number of group IDs, even if it is larger than the
/// specified size.
///
/// The current fuse kernel module in linux (as of 2.6.30) doesn't pass
/// the group list to userspace, hence this function needs to parse
/// "/proc/$TID/task/$TID/status" to get the group IDs.
///
/// This feature may not be supported on all operating systems.  In
/// such a case this function will return -ENOSYS.
///
/// @param[in] size  size of given array
/// @param[in] list  array of group IDs to be filled in
/// @see the total number of supplementary group IDs or -errno on failure
pub extern fn fuse_getgroups(size: c_int, list: [*c]gid_t) c_int;
/// Check if the current request has already been interrupted
///
/// @see 1 if the request has been interrupted, 0 otherwise
pub extern fn fuse_interrupted() c_int;
/// Invalidates cache for the given path.
///
/// This calls fuse_lowlevel_notify_inval_inode internally.
///
/// @see 0 on successful invalidation, negative error value otherwise.
///         This routine may return -ENOENT to indicate that there was
///         no entry to be invalidated, e.g., because the path has not
///         been seen before or has been forgotten; this should not be
///         considered to be an error.
pub extern fn fuse_invalidate_path(f: [*c]fuse, path: [*c]const u8) c_int;
/// The real main function
///
/// Do not call this directly, use fuse_main()
pub extern fn fuse_main_real(argc: c_int, argv: [*c][*c]u8, op: [*c]const fuse_operations, op_size: usize, private_data: ?*anyopaque) c_int;
/// Start the cleanup thread when using option "remember".
///
/// This is done automatically by fuse_loop_mt()
/// @param[in] fuse  struct fuse pointer for fuse instance
/// @see 0 on success and -1 on error
pub extern fn fuse_start_cleanup_thread(fuse: [*c]fuse) c_int;
/// Stop the cleanup thread when using option "remember".
///
/// This is done automatically by fuse_loop_mt()
/// @param[in] fuse  struct fuse pointer for fuse instance
pub extern fn fuse_stop_cleanup_thread(fuse: [*c]fuse) void;
/// Iterate over cache removing stale entries
/// use in conjunction with "-oremember"
///
/// NOTE: This is already done for the standard sessions
///
/// @param[in] fuse  struct fuse pointer for fuse instance
/// @see the number of seconds until the next cleanup
pub extern fn fuse_clean_cache(fuse: [*c]fuse) c_int;
/// Fuse filesystem object
///
/// This is opaque object represents a filesystem layer
pub const fuse_fs = extern struct {};

/// These functions call the relevant filesystem operation, and return
/// the result.
///
/// If the operation is not defined, they return -ENOSYS, with the
/// exception of fuse_fs_open, fuse_fs_release, fuse_fs_opendir,
/// fuse_fs_releasedir and fuse_fs_statfs, which return 0.
pub extern fn fuse_fs_getattr(fs: [*c]fuse_fs, path: [*c]const u8, buf: [*c]stat, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_rename(fs: [*c]fuse_fs, oldpath: [*c]const u8, newpath: [*c]const u8, flags: c_uint) c_int;
pub extern fn fuse_fs_unlink(fs: [*c]fuse_fs, path: [*c]const u8) c_int;
pub extern fn fuse_fs_rmdir(fs: [*c]fuse_fs, path: [*c]const u8) c_int;
pub extern fn fuse_fs_symlink(fs: [*c]fuse_fs, linkname: [*c]const u8, path: [*c]const u8) c_int;
pub extern fn fuse_fs_link(fs: [*c]fuse_fs, oldpath: [*c]const u8, newpath: [*c]const u8) c_int;
pub extern fn fuse_fs_release(fs: [*c]fuse_fs, path: [*c]const u8, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_open(fs: [*c]fuse_fs, path: [*c]const u8, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_read(fs: [*c]fuse_fs, path: [*c]const u8, buf: [*c]u8, size: usize, off: off_t, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_read_buf(fs: [*c]fuse_fs, path: [*c]const u8, bufp: [*c][*c]fuse_bufvec, size: usize, off: off_t, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_write(fs: [*c]fuse_fs, path: [*c]const u8, buf: [*c]const u8, size: usize, off: off_t, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_write_buf(fs: [*c]fuse_fs, path: [*c]const u8, buf: [*c]fuse_bufvec, off: off_t, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_fsync(fs: [*c]fuse_fs, path: [*c]const u8, datasync: c_int, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_flush(fs: [*c]fuse_fs, path: [*c]const u8, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_statfs(fs: [*c]fuse_fs, path: [*c]const u8, buf: [*c]statvfs) c_int;
pub extern fn fuse_fs_opendir(fs: [*c]fuse_fs, path: [*c]const u8, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_readdir(fs: [*c]fuse_fs, path: [*c]const u8, buf: ?*anyopaque, filler: fuse_fill_dir_t, off: off_t, fi: [*c]fuse_file_info, flags: fuse_readdir_flags) c_int;
pub extern fn fuse_fs_fsyncdir(fs: [*c]fuse_fs, path: [*c]const u8, datasync: c_int, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_releasedir(fs: [*c]fuse_fs, path: [*c]const u8, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_create(fs: [*c]fuse_fs, path: [*c]const u8, mode: mode_t, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_lock(fs: [*c]fuse_fs, path: [*c]const u8, fi: [*c]fuse_file_info, cmd: c_int, lock: [*c]Flock) c_int;
pub extern fn fuse_fs_flock(fs: [*c]fuse_fs, path: [*c]const u8, fi: [*c]fuse_file_info, op: c_int) c_int;
pub extern fn fuse_fs_chmod(fs: [*c]fuse_fs, path: [*c]const u8, mode: mode_t, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_chown(fs: [*c]fuse_fs, path: [*c]const u8, uid: uid_t, gid: gid_t, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_truncate(fs: [*c]fuse_fs, path: [*c]const u8, size: off_t, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_utimens(fs: [*c]fuse_fs, path: [*c]const u8, tv: [*c]const timespec, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_access(fs: [*c]fuse_fs, path: [*c]const u8, mask: c_int) c_int;
pub extern fn fuse_fs_readlink(fs: [*c]fuse_fs, path: [*c]const u8, buf: [*c]u8, len: usize) c_int;
pub extern fn fuse_fs_mknod(fs: [*c]fuse_fs, path: [*c]const u8, mode: mode_t, rdev: dev_t) c_int;
pub extern fn fuse_fs_mkdir(fs: [*c]fuse_fs, path: [*c]const u8, mode: mode_t) c_int;
pub extern fn fuse_fs_setxattr(fs: [*c]fuse_fs, path: [*c]const u8, name: [*c]const u8, value: [*c]const u8, size: usize, flags: c_int) c_int;
pub extern fn fuse_fs_getxattr(fs: [*c]fuse_fs, path: [*c]const u8, name: [*c]const u8, value: [*c]u8, size: usize) c_int;
pub extern fn fuse_fs_listxattr(fs: [*c]fuse_fs, path: [*c]const u8, list: [*c]u8, size: usize) c_int;
pub extern fn fuse_fs_removexattr(fs: [*c]fuse_fs, path: [*c]const u8, name: [*c]const u8) c_int;
pub extern fn fuse_fs_bmap(fs: [*c]fuse_fs, path: [*c]const u8, blocksize: usize, idx: [*c]u64) c_int;
pub extern fn fuse_fs_ioctl(fs: [*c]fuse_fs, path: [*c]const u8, cmd: c_uint, arg: ?*anyopaque, fi: [*c]fuse_file_info, flags: c_uint, data: ?*anyopaque) c_int;
pub extern fn fuse_fs_poll(fs: [*c]fuse_fs, path: [*c]const u8, fi: [*c]fuse_file_info, ph: ?*fuse_pollhandle, reventsp: [*c]c_uint) c_int;
pub extern fn fuse_fs_fallocate(fs: [*c]fuse_fs, path: [*c]const u8, mode: c_int, offset: off_t, length: off_t, fi: [*c]fuse_file_info) c_int;
pub extern fn fuse_fs_copy_file_range(fs: [*c]fuse_fs, path_in: [*c]const u8, fi_in: [*c]fuse_file_info, off_in: off_t, path_out: [*c]const u8, fi_out: [*c]fuse_file_info, off_out: off_t, len: usize, flags: c_int) isize;
pub extern fn fuse_fs_lseek(fs: [*c]fuse_fs, path: [*c]const u8, off: off_t, whence: c_int, fi: [*c]fuse_file_info) off_t;
pub extern fn fuse_fs_init(fs: [*c]fuse_fs, conn: [*c]fuse_conn_info, cfg: [*c]fuse_config) void;
pub extern fn fuse_fs_destroy(fs: [*c]fuse_fs) void;
pub extern fn fuse_notify_poll(ph: ?*fuse_pollhandle) c_int;
/// Create a new fuse filesystem object
///
/// This is usually called from the factory of a fuse module to create
/// a new instance of a filesystem.
///
/// @param[in] op  the filesystem operations
/// @param[in] op_size  the size of the fuse_operations structure
/// @param[in] private_data  Initial value for the `private_data`
///            field of `struct fuse_context`. May be overridden by the
///            `struct fuse_operations.init` handler.
/// @see a new filesystem object
pub extern fn fuse_fs_new(op: [*c]const fuse_operations, op_size: usize, private_data: ?*anyopaque) [*c]fuse_fs;
/// Factory for creating filesystem objects
///
/// The function may use and remove options from 'args' that belong
/// to this module.
///
/// For now the 'fs' vector always contains exactly one filesystem.
/// This is the filesystem which will be below the newly created
/// filesystem in the stack.
///
/// @param[in] args  the command line arguments
/// @param[in] fs  NULL terminated filesystem object vector
/// @see the new filesystem object
pub const fuse_module_factory_t = ?*const fn ([*c]fuse_args, [*c][*c]fuse_fs) callconv(.C) [*c]fuse_fs;

/// Get session from fuse object
pub extern fn fuse_get_session(f: [*c]fuse) [*c]fuse_session;
/// Open a FUSE file descriptor and set up the mount for the given
/// mountpoint and flags.
///
/// @param[in] mountpoint  reference to the mount in the file system
/// @param[in] options  mount options
/// @see the FUSE file descriptor or -1 upon error
pub extern fn fuse_open_channel(mountpoint: [*c]const u8, options: [*c]const u8) c_int;
